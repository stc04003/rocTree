#######################################################################
## Codes to run 1 simulated data and provide benchmark timing
#######################################################################
## Required library

library(caret)
library(flexsurv)
library(doParallel)
library(foreach)
library(survival)
library(rpart)
library(party)
library(partykit)

## Load C codes for part of split
dyn.load("tree.so")

K1 <- function(u) {
  0.75 * (1 - u ^ 2) * (abs(u) < 1)
}

K2 <- function(s, vec, h) {
    if (is.na(s)) return(rep(NA, length(vec)))
    if (s < h) return(Kq((s - vec) / h, s / h))
    else return(K1((s - vec) / h))
}

Kq <- function(x, q) {
    sigk1 <- sqrt(0.2)
    2 / (q + 1) * K1(2 / (q + 1) * (x - (q - 1) / 2)) *
        (1 + ((q - 1) / (q + 1) / sigk1) ^ 2 + 2 / sigk1 ^ 2 * (1 - q) / (1 + q) ^ 2 * x)
}

## To grow tree
## Assumes Y is sorted
grow3 <- function(Y, E, X.list, control = list()) {
    tau <- control$tau
    M <- control$M
    hN <- control$hN
    minsp <- control$minsp
    minsp2 <- control$minsp2
    N <- length(X.list[[1]][1, ])
    fitc <- survfit(Surv(Y, 1 - E) ~ 1)
    fit <- survfit(Surv(Y, E) ~ 1)
    fit$surv <- c(1, fit$surv)
    fitc$surv <- c(1, fitc$surv)
    sc <- fitc$surv[findInterval(Y, fitc$time)]
    ss <- fit$surv[findInterval(Y, fit$time)]
    Smat <- matk2 <- outer(ifelse(E, Y, NA), Y, "<=") ## opposite of Y >= Y[i]
    fmat <- matk <- t(E * sapply(ifelse(E, Y, NA), K2, vec = Y, h = hN) / hN)
    if (min(rowMeans(fmat)[E == 1]) < 0) 
        fmat[E == 1 & rowMeans(fmat) < 0, ] <- fmat[which(rowMeans(fmat) > 0)[1], ]
    Stau <- fit$surv[findInterval(tau, fit$time) + 1]
    ss <- ss[Y <= tau & E == 1]
    fall <- rowMeans(fmat)
    const <- -diff(c(ss, Stau)) / (rowMeans(fmat)[Y <= tau * E])
    ## initialization
    fTree <- STree <- matrix(NA, M, sum(Y <= E * tau))
    fTree[1, ] <- rowMeans(fmat)[Y <= tau * E]
    STree[1, ] <- rowMeans(Smat)[Y <= tau * E]
    ## Define a tree object
    treeMat <- matrix(nrow = M, ncol = 6)
    colnames(treeMat) <- c("nd", "terminal", "u", "u2", "p", "cut")
    ## terminal = 0 - internal
    ## terminal = 1 - terminal can be split
    ## terminal = 2 - terminal cannot be split
    treeMat[, 1] <- 1:M
    treeMat[, 2] <- 0
    treeMat[1, ] <- c(1, 1, 1, 1, NA, NA)
    ## node number of each observation
    ndInd <- matrix(1, N, N)
    ndInd[lower.tri(ndInd)] <- 0
    ## ndInd is N N matrix
    conTree <- sum(0.5 * const * ss * rowMeans(fmat)[Y <= tau * E])
    while (sum(treeMat[, 2] == 1) > 0) {
        sp <- split3(X.list, Y, E, fmat, Smat, treeMat, ndInd, const, fTree, STree, control)
        if (sp[1] * 2 < M & !is.na(sp[2])) {
            ndInd[ndInd == sp[1] & X.list[[sp[2]]] <= sp[3]] <- sp[1] * 2
            ndInd[ndInd == sp[1] & X.list[[sp[2]]] > sp[3]] <- sp[1] * 2 + 1
            fTree[sp[1] * 2, ] <- rowSums(fmat[Y <= tau * E, diag(ndInd) == 2 * sp[1]]) / N
            fTree[sp[1] * 2 + 1, ] <- rowSums(fmat[Y <= tau * E, diag(ndInd) == 2 * sp[1] + 1]) / N
            STree[sp[1] * 2, ] <- rowSums(Smat * (ndInd == 2 * sp[1]))[Y <= tau * E] / N
            STree[sp[1] * 2 + 1, ] <- rowSums(Smat * (ndInd == 2 * sp[1] + 1))[Y <= tau * E] / N
            treeMat[sp[1], 2] <- 0
            treeMat[sp[1], 5:6] <- sp[2:3]
            treeMat[sp[1] * 2, ] <- c(sp[1] * 2, 1,
                                      mean(diag(ndInd) == sp[1] * 2 & Y <= tau * E),
                                      min(rowMeans(ndInd[Y <= tau, ] == sp[1] * 2)), NA, NA)
            treeMat[sp[1] * 2 + 1, ] <- c(sp[1] * 2 + 1, 1,
                                          mean(diag(ndInd) == sp[1] * 2 + 1 & Y <= tau * E),
                                          min(rowMeans(ndInd[Y <= tau, ] == sp[1] * 2 + 1)), NA, NA)
            ## mean(ndInd[tlst,] == sp[1]*2)
            treeMat[treeMat[, 3] < minsp / N & treeMat[, 4] < minsp2 / N, 2] <- 2
            conTree <- conTree + sp[4]
        } else {
            treeMat[treeMat[, 1] == sp[1], 2] <- 2
            break
        }
        if (control$Trace) print(sp)
    }
    ## prune
    treeMatTerm <- treeMat[treeMat[, 2] >= 1 & is.na(treeMat[, 5]), 1]
    ## sort the node
    left <- 2 ^ round(max(log(treeMatTerm, 2)))
    right <- 2 * left - 1
    treeMatTerm2 <- treeMatTerm
    for (i in 1:length(treeMatTerm)) {
        nd <- treeMatTerm[i]
        treeMatTerm2[i] <- nd * 2 ^ ceiling(log(left / nd) / log(2))
    }
    ndTerm <- treeMatTerm <- treeMatTerm[order(treeMatTerm2)]
    ## exhaustive searching of all subtrees
    sizeTree <- length(ndTerm)
    termList <- list()
    indList <- list()
    conList <- list()
    termList[[1]] <- matrix(ndTerm, nrow = 1)
    indList[[1]] <- matrix(1, nrow = 1, ncol = sizeTree)
    fuTerm <- fTree[ndTerm[order(ndTerm)], ]
    SuTerm <- STree[ndTerm[order(ndTerm)], ]
    conList[[1]] <- .C("con",
                       as.integer(length(fuTerm) / sum(Y <= tau * E)),
                       as.integer(sum(Y <= tau * E)),
                       as.double(t(fuTerm)),
                       as.double(t(SuTerm)),
                       as.double(const), 
                       as.double(double(1)))[[6]]
    for (k in 1:(sizeTree - 1)) {
        sizeNew <- sizeTree - k
        mat1 <- termList[[k]]
        mat2 <- indList[[k]]
        num <- 0
        termMat <- matrix(ncol = sizeNew, nrow = 1)
        indMat <- matrix(ncol = sizeNew, nrow = 1)
        consub <- c()
        for (l in 1:dim(mat1)[1]) {
            ndTerml <- mat1[l, ]
            indl <- mat2[l, ]
            ## change here
            locl <- which(diff(ndTerml) == 1 & ndTerml[-length(ndTerml)] %% 2 == 0 &
                          indl[-length(ndTerml)] == 1)
            for (q in locl) {
                ndNew <- ndTerml
                ndNew[q] <- ndNew[q] / 2
                ndNew <- ndNew[-(q + 1)]
                if (l == 1 & q == locl[1]) indNew <- rep(1, sizeNew)
                else indNew <- rep(0:1, c(q - 1, sizeNew - q + 1))
                termMat <- rbind(termMat, ndNew)
                indMat <- rbind(indMat, indNew)
                num <- num + 1
                fuTerm <- fTree[ndNew[order(ndNew)], ]
                SuTerm <- STree[ndNew[order(ndNew)], ]
                consub <- c(consub, .C("con",
                                       as.integer(length(fuTerm) / sum(Y <= tau * E)),
                                       as.integer(sum(Y <= tau * E)),
                                       as.double(t(fuTerm)),
                                       as.double(t(SuTerm)),
                                       as.double(const), 
                                       as.double(double(1)))[[6]])
            }
        } ## end for l
        termMat <- termMat[-1, ]
        indMat <- indMat[-1, ]
        if (is.vector(termMat)) {
            termList[[k + 1]] <- matrix(termMat, nrow = 1)
            indList[[k + 1]] <- matrix(indMat, nrow = 1)
        } else {
            termList[[k + 1]] <- termMat
            indList[[k + 1]] <- indMat
        }
        conList[[k + 1]] <- consub
    } ## end for k
    optTreeList <- list()
    con1 <- rep(NA, length(conList))
    for (k in 1:sizeTree) {
        con1[k] <- max(conList[[k]])
        optTreeList[[k]] <- termList[[k]][which(conList[[k]] == con1[k]), ]
    }
    sz1 <- sizeTree:1
    j <- 1
    res <- matrix(c(1, 0), nrow = 1)
    while (j < sizeTree) {
        alpha <- (con1[j] - con1[-(1:j)]) / (1:(sizeTree - j))
        j <- j + which.min(alpha)
        res <- rbind(res, c(j, min(alpha)))
    }
    beta.seq <- sqrt(c(res[, 2] * c(res[-1, 2], Inf)))
    list(beta.seq = beta.seq,
         optTree.seq = optTreeList[res[, 1]],
         treeMat = treeMat)
}

## for i in length(cutAll) moved to C
split3 <- function(X, Y, E, fmat, Smat, treeMat, ndInd, const, fTree, STree, control = list())  {
    N <- dim(X[[1]])[1]
    P <- length(X)
    disc <- control$disc
    minsp <- control$minsp
    minsp2 <- control$minsp2
    M <- control$M
    tau <- control$tau
    ## all the terminal nodes that can be split; not all the terminal nodes
    nd.terminal <- treeMat[treeMat[, 2] == 1, 1]
    sopt <- matrix(NA, M, 2)
    dconopt <- rep(0, M)
    ## lnd <- length(nd.terminal)-1
    lt <- sum(Y <= tau * E)
    for (m in nd.terminal) {
        ## need to change with discrete data
        dconList <- list()
        cutList <- list()
        f <- fTree[(treeMat[, 2] >= 1) & (treeMat[, 1] != m), ]
        S <- STree[(treeMat[, 2] >= 1) & (treeMat[, 1] != m), ]
        ## size of nodes
        fm <- fTree[m, ]
        Sm <- STree[m, ]
        rm <- fm / Sm
        r <- f / S
        r[is.na(r)] <- Inf
        rm[is.na(r)] <- Inf
        for (p in 1:P) {
            ## if discrete
            if (disc[p] == 0) {
                cutAll <- sort(unique(X[[p]][1, ndInd[1, ] == m]))
            } else {
                cutAll <- sort(unique(X[[p]][ndInd == m]))
            }
            cutAll <- cutAll[-length(cutAll)]
            ## if there is no potential cut off, skip
            if (length(cutAll) == 0) {
                dconList[[p]] <- -1
                next
            }
            cutList[[p]] <- cutAll
            dconList[[p]] <- .C("cutSearch",
                                as.integer(N), ## n
                                as.integer(length(cutAll)), ## cL
                                as.integer(m), ## m
                                as.integer(which(Y <= tau * E) - 1), ## y
                                as.integer(sum(Y <= tau * E)), ## Ny
                                as.double(minsp), ## minsp
                                as.double(minsp2), ## minsp2
                                as.double(ifelse(is.na(X[[p]]), 0, X[[p]])), ## X
                                as.double(ndInd), ## ndInd
                                as.double(cutAll), ## cut
                                as.double(ifelse(is.na(fmat), 0, fmat)), ## fmat
                                as.double(ifelse(is.na(Smat), 0, Smat)), ## Smat
                                as.double(const), ## const cL by 1
                                as.double(t(f)), ## length(nd.terminal) by Ny
                                as.double(t(S)), ## length(nd.terminal) by Ny
                                as.double(t(ifelse(r == Inf, 99999, r))), ## length(nd.terminal) by Ny
                                as.double(ifelse(rm == Inf | is.na(rm), 99999, rm)), ## Ny by 1
                                as.integer(sum(treeMat[,2] >= 1 & treeMat[,1] != m)), ## sum(treeMat[,2] >= 1 & treeMat[,1] != m)
                                as.double(double(length(cutAll))))[[19]]
        } ## end P
        dconmaxP <- unlist(lapply(dconList, max))
        if (max(dconmaxP) < 0) {
            sopt[m, ] <- c(P + 1, 999)
            dconopt[m] <- -1
        } else {
            dconopt[m] <- max(dconmaxP)
            indm <- which.max(dconmaxP)
            cutindm <- cutList[[indm[1]]]
            dconindm <- dconList[[indm[1]]]
            sopt[m, ] <- c(indm[1], cutindm[which.max(dconindm)])
        }
    }
    nd.split <- which.max(dconopt)
    sopt2 <- sopt[nd.split, ]
    dconopt2 <- max(dconopt)
    c(nd.split, sopt2, dconopt2)
    ## which node to split, which variable, which cut off, which dcon
}

CV3 <- function(Y1, E1, X1.list, Y2, E2, X2.list, X12.list, beta.seq, control) {
    minsp <- control$minsp
    minsp2 <- control$minsp2
    M <- control$M
    tau <- control$tau
    hN1 <- hN2 <- control$h
    N1 <- length(X1.list[[1]][1,])
    N2 <- length(X2.list[[1]][1,])
    fitc <- survfit(Surv(c(Y1, Y2), c(1 - E1, 1 - E2)) ~ 1)
    fit <- survfit(Surv(Y1, E1) ~ 1)
    fit$surv <- c(1, fit$surv)
    fitc$surv <- c(1, fitc$surv)
    sc <- fitc$surv[findInterval(Y1, fitc$time)]
    ss <- fit$surv[findInterval(Y1, fit$time)]
    Smat <- matk2 <- outer(ifelse(E1, Y1, NA), Y1, "<=") / matrix(sc, N1, N1, TRUE)
    fmat <- matk <- t(E1 * sapply(ifelse(E1, Y1, NA), K2, vec = Y1, h = hN1) / sc / hN1)
    if (min(rowMeans(fmat)[E1 == 1]) < 0) 
        fmat[E1 == 1 & rowMeans(fmat) < 0, ] <- fmat[which(rowMeans(fmat) > 0)[1], ]
    const <- 1 / rowMeans(fmat)[Y1 <= tau * E1] / sc[Y1 <= tau * E1] / N1
    sc2 <- fitc$surv[findInterval(Y2, fitc$time)]
    Smat2 <- matk2 <- outer(ifelse(E2, Y2, NA), Y2, "<=") / matrix(sc2, N2, N2, TRUE)
    fmat2 <- matk <- t(E2 * sapply(ifelse(E2, Y2, NA), K2, vec = Y2, h = hN2) / sc2 / hN2)
    if (min(rowMeans(fmat2)[E2 == 1]) < 0) 
        fmat[E2 == 1 & rowMeans(fmat2) < 0, ] <- fmat2[which(rowMeans(fmat2) > 0)[1], ]
    const2 <- 1 / rowMeans(fmat2)[Y2 <= tau * E2] / sc2[Y2 <= tau * E2] / N2
    Smat3 <- outer(ifelse(E2, Y2, NA), Y1, "<=") 
    fmat3 <- t(E1 * sapply(ifelse(E2, Y2, NA), K2, vec = Y1, h = hN1) / hN1)
    fTree <- STree <- matrix(NA, M, sum(Y1 <= E1 * tau))
    fTree2 <- STree2 <- fTree3 <- STree3 <- matrix(NA, M, sum(Y2 <= E2 * tau))
    fTree[1, ] <- rowMeans(fmat)[Y1 <= tau * E1]
    STree[1, ] <- rowMeans(Smat)[Y1 <= tau * E1]
    fTree2[1, ] <- rowMeans(fmat2)[Y2 <= tau * E2]
    STree2[1, ] <- rowMeans(Smat2)[Y2 <= tau * E2]
    fTree3[1, ] <- rowMeans(fmat3)[Y2 <= tau * E2]
    STree3[1, ] <- rowMeans(Smat3)[Y2 <= tau * E2]
    treeMat <- matrix(nrow = M, ncol = 6)
    colnames(treeMat) <- c("nd", "terminal", "u", "u2", "p", "cut")
    treeMat[, 1] <- 1:M
    treeMat[, 2] <- 0
    treeMat[1, ] <- c(1, 1, 1, 1, NA, NA)
    ndInd1 <- matrix(1, N1, N1)
    ndInd2 <- matrix(1, N2, N2)
    ndInd12 <- matrix(1, N2, N1)
    ndInd1[lower.tri(ndInd1)] <- 0
    ndInd2[lower.tri(ndInd2)] <- 0
    ndInd12[is.na(X12.list[[1]])] <- 0
    tlst <- which(Y1 >= tau)[1] - 1
    while (sum(treeMat[, 2] == 1) > 0) {
        sp <- split3(X1.list, Y1, E1, fmat, Smat, treeMat, ndInd1, const, fTree, STree, control)
        if (sp[1] * 2 < M & !is.na(sp[2])) {
            ndInd1[ndInd1 == sp[1] & X1.list[[sp[2]]] <= sp[3]] <- sp[1] * 2
            ndInd1[ndInd1 == sp[1] & X1.list[[sp[2]]] > sp[3]] <- sp[1] * 2 + 1
            ndInd2[ndInd2 == sp[1] & X2.list[[sp[2]]] <= sp[3]] <- sp[1] * 2
            ndInd2[ndInd2 == sp[1] & X2.list[[sp[2]]] > sp[3]] <- sp[1] * 2 + 1
            ndInd12[ndInd12 == sp[1] & X12.list[[sp[2]]] <= sp[3]] <- sp[1] * 2
            ndInd12[ndInd12 == sp[1] & X12.list[[sp[2]]] > sp[3]] <- sp[1] * 2 + 1
            fTree[sp[1] * 2, ] <- rowSums(as.matrix(fmat[Y1 <= tau * E1, diag(ndInd1) == 2 * sp[1]])) / N1
            fTree[sp[1] * 2 + 1, ] <- rowSums(as.matrix(fmat[Y1 <= tau * E1, diag(ndInd1) == 2 * sp[1] + 1])) / N1
            STree[sp[1] * 2, ] <- rowSums(as.matrix(Smat * (ndInd1 == 2 * sp[1])))[Y1 <= tau * E1] / N1
            STree[sp[1] * 2 + 1, ] <- rowSums(as.matrix(Smat * (ndInd1 == 2 * sp[1] + 1)))[Y1 <= tau * E1] / N1
            fTree2[sp[1] * 2, ] <- rowSums(as.matrix(fmat2[Y2 <= tau * E2, diag(ndInd2) == 2 * sp[1]])) / N2
            fTree2[sp[1] * 2 + 1, ] <- rowSums(as.matrix(fmat2[Y2 <= tau * E2, diag(ndInd2) == 2 * sp[1] + 1])) / N2
            STree2[sp[1] * 2, ] <- rowSums(as.matrix(Smat2 * (ndInd2 == 2 * sp[1])))[Y2 <= tau * E2] / N2
            STree2[sp[1] * 2 + 1, ] <- rowSums(as.matrix(Smat2 * (ndInd2 == 2 * sp[1] + 1)))[Y2 <= tau * E2] / N2
            ## rTree2[sp[1]*2,] <- fTree2[sp[1]*2,]/STree2[sp[1]*2,]
            ## rTree2[sp[1]*2+1,] <- fTree2[sp[1]*2+1,]/STree2[sp[1]*2+1,]
            fTree3[sp[1] * 2, ] <- rowSums(as.matrix(fmat3[Y2 <= tau * E2, diag(ndInd1) == 2 * sp[1]])) / N1
            fTree3[sp[1] * 2 + 1, ] <- rowSums(as.matrix(fmat3[Y2 <= tau * E2, diag(ndInd1) == 2 * sp[1] + 1])) / N1
            STree3[sp[1] * 2, ] <- rowSums(as.matrix(Smat3 * (ndInd12 == 2 * sp[1])))[Y2 <= tau * E2] / N1
            STree3[sp[1] * 2 + 1, ] <- rowSums(as.matrix(Smat3 * (ndInd12 == 2 * sp[1] + 1)))[Y2 <= tau * E2] / N1
            ## rTree3[sp[1]*2,] <- fTree3[sp[1]*2,]/STree3[sp[1]*2,]
            ## rTree3[sp[1]*2+1,] <- fTree3[sp[1]*2+1,]/STree3[sp[1]*2+1,]
            treeMat[sp[1], 2] <- 0
            treeMat[sp[1], 5:6] <- sp[2:3]
            treeMat[sp[1] * 2, ] <- c(sp[1] * 2, 1,
                                      mean(diag(ndInd1) == sp[1] * 2 & Y1 <= tau * E1),
                                      min(rowMeans(ndInd1[Y1 <= tau, ] == sp[1] * 2)), NA, NA)
            treeMat[sp[1] * 2 + 1, ] <- c(sp[1] * 2 + 1, 1,
                                          mean(diag(ndInd1) == (sp[1] * 2 + 1) & Y1 <= tau * E1),
                                          min(rowMeans(ndInd1[Y1 <= tau, ] == sp[1] * 2 + 1)), NA, NA)
            treeMat[treeMat[, 3] <= minsp / N1 & treeMat[, 4] <= minsp2 / N1, 2] <- 2
            ## conTree <- conTree + sp[4]
        } else {
            treeMat[treeMat[, 1] == sp[1], 2] <- 2
            break
        }
    }
    ## prune
    treeMatTerm <- treeMat[treeMat[, 2] >= 1 & is.na(treeMat[, 5]), 1]
    ## sort the node
    left <- 2 ^ round(max(log(treeMatTerm, 2)))
    right <- 2 * left - 1
    treeMatTerm2 <- treeMatTerm
    for (i in 1:length(treeMatTerm)) {
        nd <- treeMatTerm[i]
        treeMatTerm2[i] <- nd * 2 ^ ceiling(log(left / nd) / log(2))
    }
    treeMatTerm <- treeMatTerm[order(treeMatTerm2)]
    ## exhaustive searching of all subtrees
    ndTerm <- treeMatTerm
    sizeTree <- length(ndTerm)
    termList <- list()
    indList <- list()
    conList <- list()
    conList2 <- list()
    termList[[1]] <- matrix(ndTerm, nrow = 1)
    indList[[1]] <- matrix(1, nrow = 1, ncol = sizeTree)
    fuTerm <- fTree[ndTerm[order(ndTerm)], ]
    SuTerm <- STree[ndTerm[order(ndTerm)], ]
    fuTerm2 <- fTree2[ndTerm[order(ndTerm)], ]
    SuTerm2 <- STree2[ndTerm[order(ndTerm)], ]
    fuTerm3 <- fTree3[ndTerm[order(ndTerm)], ]
    SuTerm3 <- STree3[ndTerm[order(ndTerm)], ]
    conList[[1]] <- .C("con", 
                       as.integer(length(fuTerm) / sum(Y1 <= tau * E1)),
                       as.integer(sum(Y1 <= tau * E1)),
                       as.double(t(fuTerm)),
                       as.double(t(SuTerm)),
                       as.double(const), 
                       as.double(double(1)))[[6]]
    conList2[[1]] <- .C("con3", 
                        as.integer(length(fuTerm2) / sum(Y2 <= tau * E2)),
                        as.integer(sum(Y2 <= tau * E2)),
                        as.double(t(fuTerm2)),
                        as.double(t(SuTerm2)),
                        as.double(t(fuTerm3)),
                        as.double(t(SuTerm3)),
                        as.double(const2),
                        as.double(double(1)))[[8]]
    ## con3(fuTerm3, SuTerm3, fuTerm2, SuTerm2, const2)
    for (k in 1:(sizeTree - 1)) {
        sizeNew <- sizeTree - k
        mat1 <- termList[[k]]
        mat2 <- indList[[k]]
        num <- 0
        termMat <- matrix(ncol = sizeNew, nrow = 1)
        indMat <- matrix(ncol = sizeNew, nrow = 1)
        consub <- c()
        con2sub <- c()
        for (l in 1:dim(mat1)[1]) {
            ndTerml <- mat1[l, ]
            indl <- mat2[l, ]
            ## change here
            locl <- which(diff(ndTerml) == 1 & ndTerml[-length(ndTerml)] %% 2 == 0 &
                          indl[-length(ndTerml)] == 1)
            for (q in locl) {
                ndNew <- ndTerml
                ndNew[q] <- ndNew[q] / 2
                ndNew <- ndNew[-(q + 1)]
                if (l == 1 & q == locl[1]) indNew <- rep(1, sizeNew)
                else indNew <- rep(0:1, c(q - 1, sizeNew - q + 1))
                termMat <- rbind(termMat, ndNew)
                indMat <- rbind(indMat, indNew)
                num <- num + 1
                fuTerm <- fTree[treeMat[, 1] %in% ndNew, ]
                SuTerm <- STree[treeMat[, 1] %in% ndNew, ]
                fuTerm2 <- fTree2[treeMat[, 1] %in% ndNew, ]
                SuTerm2 <- STree2[treeMat[, 1] %in% ndNew, ]
                fuTerm3 <- fTree3[treeMat[, 1] %in% ndNew, ]
                SuTerm3 <- STree3[treeMat[, 1] %in% ndNew, ]
                consub <- c(consub, .C("con", 
                                       as.integer(length(fuTerm) / sum(Y1 <= tau * E1)),
                                       as.integer(sum(Y1 <= tau * E1)),
                                       as.double(t(fuTerm)),
                                       as.double(t(SuTerm)),
                                       as.double(const), 
                                       as.double(double(1)))[[6]])
                con2sub <- c(con2sub, .C("con3", 
                                         as.integer(length(fuTerm2) / sum(Y2 <= tau * E2)),
                                         as.integer(sum(Y2 <= tau * E2)),
                                         as.double(t(fuTerm2)),
                                         as.double(t(SuTerm2)),
                                         as.double(t(fuTerm3)),
                                         as.double(t(SuTerm3)),
                                             as.double(const2),
                                         as.double(double(1)))[[8]])
            }
        }
        termMat <- termMat[-1, ]
        indMat <- indMat[-1, ]
        if (is.vector(termMat)) {
            termList[[k + 1]] <- matrix(termMat, nrow = 1)
            indList[[k + 1]] <- matrix(indMat, nrow = 1)
        } else {
            termList[[k + 1]] <- termMat
            indList[[k + 1]] <- indMat
        }
        conList[[k + 1]] <- consub
        conList2[[k + 1]] <- con2sub
    }
    con1 <- unlist(lapply(conList, max))
    sz1 <- sizeTree:1
    j <- 1
    res <- matrix(c(1, 0), nrow = 1)
    while (j < sizeTree) {
        alpha <- (con1[j] - con1[-(1:j)]) / (1:(sizeTree - j))
        j <- j + tail(which(alpha == min(alpha)), 1)
        res <- rbind(res, c(j, min(alpha)))
    }
    con2opt <- (unlist(lapply(conList2, max)))[res[, 1]]
    con1opt <- con1[res[, 1]]
    res <- cbind(res, con1opt, con2opt)
    res <- rbind(res, c(100, Inf, 0, 0))
    ## beta.seq <- c(0.0001,0.001,0.01,0.1)
    cvconbb <- function(bb) res[which(res[, 2] >= bb)[1] - 1, 4]
    cvcon2 <- sapply(beta.seq[-length(beta.seq)], cvconbb)
    c(unlist(cvcon2), tail(res[, 4], 2)[1])
}

## Calculate CON

con <- function(fuTerm, SuTerm, const) {
    if (is.vector(fuTerm)) {
        fuTerm <- t(as.matrix(fuTerm))
        SuTerm <- t(as.matrix(SuTerm))
    }
    mnd <- dim(fuTerm)[1]
    ind1 <- matrix(rep(1:mnd, mnd), mnd, mnd)
    ind2 <- matrix(rep(1:mnd, each = mnd), mnd, mnd)
    matfs1 <- fuTerm[as.vector(ind1), ] * SuTerm[as.vector(ind2), ]
    matfs1 <- t(t(matfs1) * const)
    matfs2 <- fuTerm[as.vector(ind2), ] * SuTerm[as.vector(ind1), ]
    matfs2 <- t(t(matfs2) * const)
    sum(matfs1[matfs1 > matfs2]) + 0.5 * sum(matfs1[matfs1 == matfs2])
}


con3 <- function(fuTerm3, SuTerm3, fuTerm2, SuTerm2, const2) {
    if (is.vector(fuTerm3)) {
        fuTerm3 <- t(as.matrix(fuTerm3))
        SuTerm3 <- t(as.matrix(SuTerm3))
        fuTerm2 <- t(as.matrix(fuTerm2))
        SuTerm2 <- t(as.matrix(SuTerm2))
    }
    mnd <- dim(fuTerm3)[1]
    ind1 <- matrix(rep(1:mnd, mnd), mnd, mnd)
    ind2 <- matrix(rep(1:mnd, each = mnd), mnd, mnd)
    matfs1 <- fuTerm2[as.vector(ind1), ] * SuTerm2[as.vector(ind2), ]
    matfs1 <- t(t(matfs1) * const2)
    matfs2 <- fuTerm2[as.vector(ind2), ] * SuTerm2[as.vector(ind1), ]
    matfs2 <- t(t(matfs2) * const2)
    matfs3 <- fuTerm3[as.vector(ind1), ] * SuTerm3[as.vector(ind2), ]
    matfs4 <- fuTerm3[as.vector(ind2), ] * SuTerm3[as.vector(ind1), ]
    sum(matfs1[matfs3 > matfs4]) + 0.5 * sum(matfs1[matfs3 == matfs4])
}

#######################################################################
## Run codes:
#######################################################################
## Codes to generate simulation data in a data frame that's in a common format

## STarting to put things in package form
## Scenario III on page 18
datGen <- function(n) {
    ## 3 covariates, X1 and x2 are used in the paper, X3 is a noise
    lambda <- .1
    P <- 2
    U <- runif(n)
    X <- matrix(runif(n * P, 0, 1), ncol = P, nrow = n)
    a <- X[, 1]
    b <- X[, 2]
    betat <- 2
    beta <- 1
    ks <- runif(n, 1, 2)
    it <- runif(n, 1, 2)
    T <- log(1 + (betat * ks * (-log(U))) / lambda / exp(beta * a + betat * it)) / betat / ks
    C <- runif(n, 0, .8)
    Y <- pmin(T, C)
    E <- T <= C ## censoring indicator
    dat <- NULL ## ID, Time, Status, X1, X2, X3
    for (i in 1:n) {
        dat <- rbind(dat, cbind(rep(i, rank(Y)[i]), Y[which(Y <= Y[i])], E[i], a[i], Y[which(Y <= Y[i])] * ks[i] + it[i], runif(1)))
    }
    dat <- data.frame(dat)
    colnames(dat) <- c("ID", "Time", "Status", "X1", "X2", "X3")
    dat <- dat[order(dat$ID, dat$Time),]
    rownames(dat) <- NULL
    dat
}

set.seed(12)
## dat <- datGen(15)
dat <- datGen(100)
foo <- rocTree(Surv(Time, Status) ~ X1 + X2, id = ID, data = dat)
str(foo)

foo <- rocTree(Surv(Time, Status) ~ X1 + X2, id = ID, data = dat, control = list(CV = TRUE, Trace = FALSE))
str(foo)


foo <- rocTree(Surv(Time, Status) ~ X1 + X2 + X3, id = ID, data = dat)
foo <- rocTree(Surv(Time, Status) ~ X1, id = ID, data = dat)
table(foo$treeMat[,5])

debug(rocTree)

foo <- rocTree(Surv(Time, Status) ~ X3 + X1 + X2, id = ID, data = dat)

rocTree <- function(formula, data, id, subset, control = list()) {
    ctrl <- rocTree.control()
    namc <- names(control)
    if (!all(namc %in% names(ctrl))) 
        stop("unknown names in control: ", namc[!(namc %in% names(ctrl))])
    ctrl[namc] <- control
        Call <- match.call()
    indx <- match(c("formula", "data", "id", "subset"), names(Call), nomatch = 0L)
    if (indx[1] == 0L) stop("A 'formula' argument is required")
    tmp <- Call[c(1L, indx)]
    tmp[[1L]] <- quote(stats::model.frame)
    ## prepare data
    m <- eval.parent(tmp)
    Y <- model.response(m)[,1]
    Status <- model.response(m)[,2]
    id <- model.extract(m, id)
    if (is.null(id)) id <- 1:nrow(m)
    Y0 <- unlist(lapply(split(Y, id), max))
    ## sort m by Y0
    DF <- do.call(rbind, split(m, id)[unique(id)[order(Y0)]])
    rownames(DF) <- NULL
    Y <- model.response(DF)[,1]
    Status <- model.response(DF)[,2]
    id <- model.extract(DF, id)
    Y0 <- unlist(lapply(split(Y, id), max))
    if (!any(Y %in% Y0)) {
        DF <- DF[Y %in% Y0,]
        Y <- model.response(DF)[,1]
        id <- model.extract(DF, id)
    }
    if (is.null(id)) {id <- 1:nrow(DF)
    } else {id <- rep(1:length(unique(id)), table(factor(id, levels = unique(id))))}
    X <- model.matrix(attr(m, "terms"), DF)
    if (sum(colnames(X) == "(Intercept)") > 0) 
        X <- as.matrix(X[, -which(colnames(X) == "(Intercept)")])
    p <- ncol(X)
    if (is.null(ctrl$disc)) ctrl$disc <- rep(0, p)
    if (length(ctrl$disc) == 1) ctrl$disc <- rep(ctrl$disc, p)
    xlist <- sapply(1:p, function(z) rocTree.Xlist(X[,z], ctrl$disc[z], Y, id), simplify = FALSE)
    Y0 <- unlist(lapply(split(Y, id), max), use.names = FALSE)
    E0 <- unlist(lapply(split(Status, id), max), use.names = FALSE)
    out <- grow3(Y0, E0, xlist, ctrl)
    if (ctrl$CV) out$con2.seq <- rocTree.cv(out$beta.seq, Y, Status, id, X, ctrl)
    return(out)
}

rocTree.control <- function(tau = 0.4, M = 1000, hN = tau / 20, h = hN, minsp = 20, minsp2 = 5, disc = 0, nflds = 10, CV = FALSE, Trace = TRUE) {
    list(tau = tau, M = M, hN = hN, h = h, minsp = minsp, minsp2 = minsp2, disc = disc, nflds = nflds, CV = CV, Trace = Trace)
}

is.rocTree <- function(x) inherits(x, "rocTree")

rocTree.Xlist <- function(x, disc, y, id) {
    yi <- unlist(lapply(split(y, id), max), use.names = FALSE)
    m <- unlist(lapply(split(y, id), length), use.names = FALSE)
    n <- length(unique(id))
    tmp <- unlist(lapply(split(y, id), function(z) match(yi, z))) + rep(c(0, cumsum(m)[-length(m)]), each = n)
    xlist <- matrix(x[tmp], n)
    if (!disc) xlist <- t(apply(xlist, 1, rank, na.last = "keep")) / rowSums(!is.na(xlist))
    return(xlist)
}

con.cv <- function(y, id, ind, d, x0, beta.seq, control) {
    yi <- unlist(lapply(split(y, id), max), use.names = FALSE)
    di <- unlist(lapply(split(d, id), max), use.names = FALSE)
    n <- length(unique(id))
    p <- length(x0)
    y1 <- yi[-ind]
    y2 <- yi[ind]
    d1 <- di[-ind]
    d2 <- di[ind]
    x1 <- x2 <- x12 <- list()
    n1 <- length(y1)
    n2 <- length(y2)
    for (i in 1:p) {
        x1[[i]] <- x0[[i]][-ind, -ind]
        x2[[i]] <- x0[[i]][ind, ind]
        x12[[i]] <- x0[[i]][ind, -ind]
        if (!control$disc[i]) {
            x1tmp <- x1[[i]]
            x2tmp <- x12[[i]]
            x2tmp[rowSums(!is.na(x2tmp)) == 0,] <- 1
            x1[[i]] <- t(apply(x1tmp, 1, rank, ties.method = 'min', na.last = "keep")) / rowSums(!is.na(x1tmp))
            x2[[i]] <- t(sapply(1:n2, function(x) findInterval(x2[[i]][x,], sort(x2tmp[x,])) / sum(!is.na(x2tmp[x,]))))
            x12[[i]] <-t(sapply(1:n2, function(x) findInterval(x12[[i]][x,], sort(x2tmp[x,])) / sum(!is.na(x2tmp[x,]))))
        }
    }
    CV3(y1, d1, x1, y2, d2, x2, x12, beta.seq, control)
}

rocTree.cv <- function(beta.seq, Y, Status, id, X, control = list()) {
    n <- length(unique(id))
    nflds <- control$nflds
    flds <- split(sample(1:n, n), c(rep(1:k, each = floor(n / k)), 1:(n %% k)))
    ## flds <- createFolds(1:n, k = nflds, list = TRUE, returnTrain = FALSE)
    p <- ncol(X)
    x0list <- sapply(1:p, function(z) rocTree.Xlist(X[,z], 1, Y, id), simplify = FALSE)
    con2.seq <- sapply(1:nflds, function(x) con.cv(Y, id, flds[[x]], Status, x0list, beta.seq, control))
    colnames(con2.seq) <- paste("Fold", 1:nflds, sep = "")
    rownames(con2.seq) <- NULL
    con2.seq
}



createFolds(1:10, k = 6, list = TRUE, returnTrain = FALSE)

n <- 20
k <- 6
sample(1:n, n)
c(rep(1:k, each = floor(n / k)), 1:(n %%k))

split(sample(1:n, n), c(rep(1:k, each = floor(n / k)), 1:(n %%k)))
e
###################################################################
## Data preparation; user provided codes/data

set.seed(12)
N <- 200
M <- 1000 ## max node number
P <- 2 ## Dimension of X
minsp <- 20
minsp2 <- 5 ## Not sure what are these??
disc <- c(0, 0)
U <- runif(N)
X <- matrix(runif(N * P, 0, 1), ncol = P, nrow = N)
a <- X[, 1]
b <- X[, 2]
betat <- 2
beta <- 1
lambda <- .1
ks <- runif(N, 1, 2)
it <- runif(N, 1, 2)
T <- log(1 + (betat * ks * (-log(U))) / lambda / exp(beta * a + betat * it)) / betat / ks
C <- runif(N, 0, .8)
tau <- .4
Y <- pmin(T, C)
E <- T <= C ## censoring indicator

X <- X[order(Y), ]
a <- a[order(Y)]
b <- b[order(Y)]
E <- E[order(Y)]
ks <- ks[order(Y)]
it <- it[order(Y)]
Y <- Y[order(Y)]

P1 <- 1
P2 <- 2

## N3 = n_0; these '3' are for the validation sets
N3 <- 1000
U3 <- runif(N3)
X3 <- matrix(runif(N3 * (P), 0, 1), ncol = P, nrow = N3)
a3 <- X3[, 1]
b3 <- X3[, 2]
k3 <- runif(N3, 1, 2)
it3 <- runif(N3, 1, 2)

## disc <- c(0, 0) + 1

X.list = list()
X0.list = list()
X32.list = list()

for (p in 1:P2) {
    if (p <= P1) {
        Xtmp <- rep(1, N) %*% t(X[,p])
        Xtmp[lower.tri(Xtmp, diag = FALSE)] <- NA
        X0.list[[p]] <- X.list[[p]] <- Xtmp
        X32.list[[p]] <- rep(1, N) %*% t(X3[,p])
    }
    if (p > P1) {
        Xtmp <- t(t(matrix(Y, N, N)) * matrix(ks, N, N) + matrix(it, N, N))
        Xtmp[lower.tri(Xtmp, diag = FALSE)] <- NA        
        X0.list[[p]] <- X.list[[p]] <- Xtmp
        X32.list[[p]] <- t(t(matrix(Y, N, N3)) * matrix(k3, N3, N) + matrix(it3, N3, N))
    }
    if (disc[p] == 0) {
        X.list[[p]] <- t(apply(Xtmp, 1, rank, na.last = "keep")) / N:1
        X32.list[[p]] <- t(sapply(1:N, function(x)
            findInterval(X32.list[[p]][x,], sort(Xtmp[x,])))) / N:1
    }
}

h <- tau / 20
hN <- h
system.time(tree <- grow3(Y, E, X.list))
##    user  system elapsed 
##   1.048   0.000   1.048 

library(rpart)
X1 <- X[,1]
X2 <- X.list[[2]][1,]
fit <- rpart(Surv(Y, E) ~ X1 + X2)





beta.seq <- tree[[1]]
nflds <- 10 ## ten fold CV to choose \alpha
flds <- createFolds(1:N, k = nflds, list = TRUE, returnTrain = FALSE)
h <- h * 1.2

ptm <- proc.time()
con2.seq <- matrix(NA, 8, 10)
if (length(beta.seq) > 2) {
    for(i in 1:nflds) {
        ind <- flds[[i]]
        Y1 <- Y[-ind]
        Y2 <- Y[ind]
        E1 <- E[-ind]
        E2 <- E[ind]
        X1.list <- list()
        X2.list <- list()
        X12.list <- list()
        X21.list <- list()
        N1 <- length(Y1)
        N2 <- length(Y2)
        hN1 <- h
        hN2 <- h
        for (p in 1:(P)) {
            X1.list[[p]] <- X0.list[[p]][-ind,-ind]
            X2.list[[p]] <- X0.list[[p]][ind, ind]
            X21.list[[p]] <- X0.list[[p]][-ind, ind]
            X12.list[[p]] <- X0.list[[p]][ind,-ind]
            if (disc[p] == 0) {
                x1tmp <- X1.list[[p]]
                x2tmp <- X12.list[[p]]
                x2tmp[rowSums(!is.na(x2tmp)) == 0,] <- 1
                X1.list[[p]] <- t(apply(x1tmp, 1, rank, ties.method = 'min', na.last = "keep")) / rowSums(!is.na(x1tmp))
                X2.list[[p]] <- t(sapply(1:N2, function(x) findInterval(X2.list[[p]][x,], sort(x2tmp[x,])) / sum(!is.na(x2tmp[x,]))))
                X21.list[[p]] <-t(sapply(1:N1, function(x) findInterval(X21.list[[p]][x,], sort(x1tmp[x,])) / sum(!is.na(x1tmp[x,]))))
                X12.list[[p]] <-t(sapply(1:N2, function(x) findInterval(X12.list[[p]][x,], sort(x2tmp[x,])) / sum(!is.na(x2tmp[x,]))))
            }
        }
        con2.seq[,i] <- CV3(Y1, E1, X1.list, Y2, E2, X2.list, X12.list, beta.seq)
    }
}
proc.time() - ptm
 ##   user  system elapsed 
 ## 10.525   0.014  11.194 

colnames(con2.seq) <- paste("result.", 1:10, sep = "")

