#######################################################################
## Load package
#######################################################################

library(rocTree)
library(survival)

#######################################################################
## mimicking
#######################################################################

datGen <- function(n) {
    ## 3 covariates, X1 and x2 are used in the paper, X3 is a noise
    lambda <- .1
    P <- 2
    U <- runif(n)
    X <- matrix(runif(n * P, 0, 1), ncol = P, nrow = n)
    a <- X[, 1]
    b <- X[, 2]
    betat <- 2
    beta <- 1
    ks <- runif(n, 1, 2)
    it <- runif(n, 1, 2)
    T <- log(1 + (betat * ks * (-log(U))) / lambda / exp(beta * a + betat * it)) / betat / ks
    C <- runif(n, 0, .8)
    Y <- pmin(T, C)
    E <- T <= C ## censoring indicator
    dat <- NULL ## ID, Time, Status, X1, X2, X3
    for (i in 1:n) {
        dat <- rbind(dat, cbind(rep(i, rank(Y)[i]), Y[which(Y <= Y[i])], 0, a[i],
                                Y[which(Y <= Y[i])] * ks[i] + it[i], runif(1)))
    }
    dat <- data.frame(dat)
    colnames(dat) <- c("ID", "Time", "Status", "X1", "X2", "X3")
    dat <- dat[order(dat$ID, dat$Time),]
    rownames(dat) <- NULL
    dat$Status[cumsum(aggregate(Time ~ ID, dat, length)[,2])] <- E
    dat
}
